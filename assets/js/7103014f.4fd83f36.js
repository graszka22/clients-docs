"use strict";(self.webpackChunkclients_tutorial=self.webpackChunkclients_tutorial||[]).push([[441],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>h});var i=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=i.createContext({}),c=function(e){var n=i.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=c(e.components);return i.createElement(s.Provider,{value:n},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},m=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=c(t),m=a,h=p["".concat(s,".").concat(m)]||p[m]||u[m]||o;return t?i.createElement(h,r(r({ref:n},d),{},{components:t})):i.createElement(h,r({ref:n},d))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,r=new Array(o);r[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[p]="string"==typeof e?e:a,r[1]=l;for(var c=2;c<o;c++)r[c]=t[c];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}m.displayName="MDXCreateElement"},7988:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var i=t(7462),a=(t(7294),t(3905));const o={},r="Android Quickstart Guide",l={unversionedId:"quickstart/android-quickstart",id:"quickstart/android-quickstart",title:"Android Quickstart Guide",description:"What you'll learn",source:"@site/docs/quickstart/android-quickstart.mdx",sourceDirName:"quickstart",slug:"/quickstart/android-quickstart",permalink:"/clients-docs/docs/quickstart/android-quickstart",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/quickstart/android-quickstart.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Quickstart",permalink:"/clients-docs/docs/category/quickstart"},next:{title:"React Native / Expo Quickstart Guide",permalink:"/clients-docs/docs/quickstart/react-native-quickstart"}},s={},c=[{value:"What you&#39;ll learn",id:"what-youll-learn",level:2},{value:"What do you need",id:"what-do-you-need",level:2},{value:"Setup",id:"setup",level:2},{value:"Add dependencies",id:"add-dependencies",level:3},{value:"AndroidManifest.xml changes",id:"androidmanifestxml-changes",level:3},{value:"Start the Jellyfish backend",id:"start-the-jellyfish-backend",level:3},{value:"Start the dashboard web frontend",id:"start-the-dashboard-web-frontend",level:3},{value:"Connecting to the server and joining the room",id:"connecting-to-the-server-and-joining-the-room",level:2},{value:"App structure",id:"app-structure",level:3},{value:"Connect screen",id:"connect-screen",level:3},{value:"QR Code scanning",id:"qr-code-scanning",level:3},{value:"Handling camera permissions",id:"handling-camera-permissions",level:3},{value:"Connecting to the backend",id:"connecting-to-the-backend",level:3},{value:"Room screen",id:"room-screen",level:2},{value:"Adding / removing peers and tracks",id:"adding--removing-peers-and-tracks",level:3},{value:"Gracefully leaving the room",id:"gracefully-leaving-the-room",level:3},{value:"Summary",id:"summary",level:2}],d={toc:c},p="wrapper";function u(e){let{components:n,...o}=e;return(0,a.kt)(p,(0,i.Z)({},d,o,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"android-quickstart-guide"},"Android Quickstart Guide"),(0,a.kt)("h2",{id:"what-youll-learn"},"What you'll learn"),(0,a.kt)("p",null,"This tutorial will guide you through creating your first Android project which\nuses Jellyfish client. By the end of the tutorial you'll have a working\napplication that connects to the frontend dashboard using WebRTC technology and\nstreams and receives camera tracks."),(0,a.kt)("p",null,"// TODO: finished app here"),(0,a.kt)("p",null,"You can check out the finished project ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/graszka22/clients-docs"},"here"),"."),(0,a.kt)("h2",{id:"what-do-you-need"},"What do you need"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"a little bit of experience in creating Android apps and Jetpack Compose"),(0,a.kt)("li",{parentName:"ul"},"Android Studio, Android device")),(0,a.kt)("h2",{id:"setup"},"Setup"),(0,a.kt)("h3",{id:"add-dependencies"},"Add dependencies"),(0,a.kt)("p",null,"Firstly add Jitpack repository in your app's ",(0,a.kt)("inlineCode",{parentName:"p"},"settings.gradle")," file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-gradle"},"dependencyResolutionManagement {\n    repositories {\n        google()\n        mavenCentral()\n        // highlight-next-line\n        maven { url 'https://jitpack.io' }\n    }\n}\n")),(0,a.kt)("p",null,"Then add Jellyfish Client dependency:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-gradle"},"dependencies {\n    implementation 'com.github.jellyfish-dev:android-client-sdk:<<version>>'\n}\n")),(0,a.kt)("h3",{id:"androidmanifestxml-changes"},"AndroidManifest.xml changes"),(0,a.kt)("p",null,"In order to connect to the backend without setting up https add this line in\n",(0,a.kt)("inlineCode",{parentName:"p"},"AndroidManifest.xml"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'    <application\n        ...\n        // highlight-next-line\n        android:usesCleartextTraffic="true">\n')),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"Don't add this line it in production apps! Using https is essential for users' security.")),(0,a.kt)("h3",{id:"start-the-jellyfish-backend"},"Start the Jellyfish backend"),(0,a.kt)("p",null,"For testing, we'll run the backend locally using Docker image:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"docker run -p 50000-50050:50000-50050/udp \\\n           -p 4000:4000/tcp \\\n           -e WEBRTC_USED=true \\\n           -e INTEGRATED_TURN_PORT_RANGE=50000-50050 \\\n           -e INTEGRATED_TURN_IP=192.168.0.1 \\\n           -e INTEGRATED_TURN_LISTEN_IP=0.0.0.0 \\\n           -e SERVER_API_TOKEN=development \\\n           -e VIRTUAL_HOST=192.168.0.1 \\\n           -e SECRET_KEY_BASE=secret \\\n           ghcr.io/jellyfish-dev/jellyfish:edge\n")),(0,a.kt)("p",null,"Make sure to set ",(0,a.kt)("inlineCode",{parentName:"p"},"INTEGRATED_TURN_IP")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"VIRTUAL_HOST")," to your local IP address. Without it, the mobile device won't be able to connect to the backend."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"To check your local IP you can use this handy command (Linux/macOS):"),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"ifconfig | grep \"inet \" | grep -Fv 127.0.0.1 | awk '{print $2}'\n"))),(0,a.kt)("h3",{id:"start-the-dashboard-web-frontend"},"Start the dashboard web frontend"),(0,a.kt)("p",null,"// TODO nie wiem jak to ostatecznie bedzie wygl\u0105da\u0107"),(0,a.kt)("h2",{id:"connecting-to-the-server-and-joining-the-room"},"Connecting to the server and joining the room"),(0,a.kt)("p",null,"Our app will consist of two screens. The first one allows user to type, paste or\nscan the peer token and connect to the room. The second screen shows room participants with their video tracks."),(0,a.kt)("p",null,"Note that normally the app gets the peer token from your backend. In this\nexample though we skip that and just copy it from the dashboard to the app to\nmake it easier. Here is how to do it:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Adding mobile peer in the dashboard",src:t(2596).Z,width:"1760",height:"1148"})),(0,a.kt)("h3",{id:"app-structure"},"App structure"),(0,a.kt)("p",null,"To write the app we'll use Jetpack Compose. Firstly, create a new Android Studio\nproject with empty Activity."),(0,a.kt)("p",null,"Then, we'll replace the default app theme. Feel free to skip this step and style\nyour components however you want, we just put them there for completness."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:"title=Color.kt",title:"Color.kt"},"package com.example.jellyfishdashboardandroid.ui.theme\n\nval seaBlue40 = Color(0xFFBFE7F8)\nval seaBlue20 = Color(0xFFF1FAFE)\nval darkBlue100 = Color(0xFF001A72)\nval white = Color(0xFFFFFFFF)\nval darkText = Color(0xFF001A72)\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:"title=Theme.kt",title:"Theme.kt"},"package com.example.jellyfishdashboardandroid.ui.theme\n\nprivate val LightColorScheme = lightColorScheme(\n    primary = darkBlue100,\n    background = seaBlue40,\n    onPrimary = white,\n)\n\n@Composable\nfun JellyfishDashboardAndroidTheme(\n    content: @Composable () -> Unit\n) {\n    MaterialTheme(\n        colorScheme = LightColorScheme,\n        typography = Typography,\n        content = content\n    )\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:"title=Type.kt",title:"Type.kt"},"package com.example.jellyfishdashboardandroid.ui.theme\n\nval Typography = Typography(\n    bodyLarge = TextStyle(\n        fontFamily = FontFamily.Default,\n        fontWeight = FontWeight.Normal,\n        fontSize = 16.sp,\n        lineHeight = 28.sp,\n        letterSpacing = 0.5.sp\n    ),\n    labelLarge = TextStyle(\n        fontFamily = FontFamily.Default,\n        fontWeight = FontWeight.W600,\n        fontSize = 18.sp,\n        lineHeight = 24.sp,\n        letterSpacing = 1.sp,\n    ),\n)\n")),(0,a.kt)("p",null,"Our app will contain one activity: we'll leave it named ",(0,a.kt)("inlineCode",{parentName:"p"},"MainActivity")," at it\nshould be already created by Android Studio. This activity will be paired with\none ",(0,a.kt)("inlineCode",{parentName:"p"},"ViewModel"),", we'll name it ",(0,a.kt)("inlineCode",{parentName:"p"},"MainViewModel"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:"title=MainViewModel.kt",title:"MainViewModel.kt"},"class MainViewModel(application: Application) : AndroidViewModel(application) {\n\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:"title=MainActivity.kt",title:"MainActivity.kt"},"class MainActivity : ComponentActivity() {\n    private val viewModel: MainViewModel by viewModels()\n\n    //...\n}\n")),(0,a.kt)("p",null,"In ",(0,a.kt)("inlineCode",{parentName:"p"},"MainActivity.kt")," we'll store code responsible for displaying things (UI). In\n",(0,a.kt)("inlineCode",{parentName:"p"},"MainViewModel.kt")," we'll store a class responsible for the business logic of the\napp (storing data, managing state of the app, connecting to the server)."),(0,a.kt)("p",null,"Of course your app might be a lot more complicated and use a different\nstructure. The two screens should be probably separated as different activities /\nfragments. For this tutorial though, this simple structure should be enough."),(0,a.kt)("h3",{id:"connect-screen"},"Connect screen"),(0,a.kt)("p",null,"The UI of the Connect screen consists of a simple text input and a few buttons.\nThe flow for this screen is simple: user either copies the peer token from the\ndashboard or scans it with QR code scanner and presses Connect button. The QR\ncode scanner is provided by our components library and it's completely optional,\njust for convenience."),(0,a.kt)("p",null,"Firstly, we need to store the peer token somewhere in the ViewModel:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:"MainViewModel.kt","MainViewModel.kt":!0},'class MainViewModel(application: Application) : AndroidViewModel(application) {\n    val peerToken = MutableStateFlow("")\n}\n')),(0,a.kt)("p",null,"Then we'll add code for the UI:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:"MainActivity.kt","MainActivity.kt":!0},'class MainActivity : ComponentActivity() {\n    //...\n\n    @Composable\n    fun ConnectContent() {\n        val peerToken = viewModel.peerToken.collectAsState()\n\n        Column(\n            modifier = Modifier\n                .fillMaxWidth()\n                .fillMaxHeight()\n                .padding(10.dp),\n            verticalArrangement = Arrangement.spacedBy(\n                24.dp, alignment = Alignment.CenterVertically\n            ),\n        ) {\n            OutlinedTextField(\n                singleLine = true,\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .height(56.dp),\n                shape = CircleShape,\n                value = peerToken.value,\n                onValueChange = { it: String -> viewModel.peerToken.value = it },\n                colors = TextFieldDefaults.textFieldColors(\n                    containerColor = Color.White\n                )\n            )\n            Button(\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .height(56.dp),\n                onClick = { connect() } // we\'ll add this method soon\n            ) {\n                Text("Connect")\n            }\n            Button(\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .height(56.dp),\n                onClick = { scanQRCode() }) { // we\'ll add this method soon\n                Text("QR code")\n            }\n        }\n    }\n}\n')),(0,a.kt)("h3",{id:"qr-code-scanning"},"QR Code scanning"),(0,a.kt)("p",null,"We know that copy-paste from desktop to mobile device is annoying. That's why to\ncopy the peer token from the dashboard we'll use QR code scanning. It's actually\nquite easy to add if we use a Google library to do it: no need for creating the\nUI, opening the camera, handling permissions etc. - everything is handled by the\nlibrary \ud83c\udf89"),(0,a.kt)("p",null,"Firstly, add a dependency in your ",(0,a.kt)("inlineCode",{parentName:"p"},"build.gradle"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-gradle",metastring:"title=build.gradle",title:"build.gradle"},"implementation 'com.google.android.gms:play-services-code-scanner:16.1.0'\n")),(0,a.kt)("p",null,"Then scan the code like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:"title=MainActivity.kt",title:"MainActivity.kt"},"class MainActivity : ComponentActivity() {\n    //...\n\n    private fun scanQRCode() {\n        val options = GmsBarcodeScannerOptions.Builder().setBarcodeFormats(\n            Barcode.FORMAT_QR_CODE, Barcode.FORMAT_AZTEC\n        ).enableAutoZoom().build()\n\n        val scanner = GmsBarcodeScanning.getClient(this, options)\n\n        scanner.startScan().addOnSuccessListener { barcode ->\n            val rawValue: String? = barcode.rawValue\n            if (rawValue != null) {\n                viewModel.peerToken.value = rawValue\n            }\n        }.addOnCanceledListener {\n            // Task canceled\n        }.addOnFailureListener { e ->\n            // Task failed with an exception\n        }\n    }\n}\n")),(0,a.kt)("p",null,"Make sure to handle the errors gracefully. Now if you scan the code, the peer\ntoken should appear in the text field."),(0,a.kt)("h3",{id:"handling-camera-permissions"},"Handling camera permissions"),(0,a.kt)("p",null,"Before we start connecting we want to have camera permissions sorted out. On\nAndroid we need to ask the user for a permission to use the camera before\ncreating camera track."),(0,a.kt)("p",null,"We're lazy, so we'll use a handy Google library for that:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-gradle",metastring:"title=build.gradle",title:"build.gradle"},"implementation 'com.google.accompanist:accompanist-permissions:0.28.0'\n")),(0,a.kt)("p",null,'If we don\'t have camera permission yet, we\'ll display "Request permissions"\nbutton, instead of "Connect" button. The button requests camera permissions. If\nthe permission is granted, we\'ll display "Connect" button instead:'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:"title=MainActivity.kt",title:"MainActivity.kt"},'    // highlight-start\n    @OptIn(ExperimentalPermissionsApi::class)\n    @Composable\n    fun ConnectButton(modifier: Modifier) {\n        val cameraPermissionState = rememberPermissionState(\n            android.Manifest.permission.CAMERA\n        )\n\n        if (cameraPermissionState.status.isGranted) {\n            Button(onClick = { viewModel.connect() }, modifier = modifier) {\n                Text("Connect")\n            }\n        } else {\n            Button(\n                onClick = { cameraPermissionState.launchPermissionRequest() }, modifier = modifier\n            ) {\n                Text("Request camera permissions")\n            }\n        }\n    }\n    // highlight-end\n\n    // ...\n\n    fun ConnectContent() {\n        // ...\n\n        Column(\n            // ...\n        ) {\n            OutlinedTextField(\n               // ...\n            )\n            // highlight-start\n            ConnectButton(\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .height(56.dp)\n            )\n            // highlight-end\n            Button(\n                // ...\n            ) {\n                Text("QR code")\n            }\n        }\n    }\n')),(0,a.kt)("h3",{id:"connecting-to-the-backend"},"Connecting to the backend"),(0,a.kt)("p",null,"Finally we can write code to actually connect to the backend. It will be the\nresponsibility of the ",(0,a.kt)("inlineCode",{parentName:"p"},"MainViewModel"),"."),(0,a.kt)("p",null,"Firstly, create ",(0,a.kt)("inlineCode",{parentName:"p"},"JellyfishClient"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:"title=MainViewModel.kt",title:"MainViewModel.kt"},"class MainViewModel(application: Application) : AndroidViewModel(application) {\n    //...\n    // highlight-next-line\n    private val client = JellyfishClient(getApplication(), this)\n}\n")),(0,a.kt)("p",null,"Then write the ",(0,a.kt)("inlineCode",{parentName:"p"},"connect()")," function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:"title=MainViewModel.kt",title:"MainViewModel.kt"},'class MainViewModel(application: Application) : AndroidViewModel(application) {\n    //...\n    // highlight-start\n    fun connect() {\n        client.connect(\n            Config(\n                websocketUrl = "ws://192.168.0.1:4000/socket/peer/websocket",\n                token = peerToken.value,\n            ),\n        )\n    }\n    // highlight-end\n}\n')),(0,a.kt)("p",null,"the ",(0,a.kt)("inlineCode",{parentName:"p"},"websocketUrl")," is the url of Jellyfish backend, be sure to change it to your\nlocal backend. Also we strongly recommend storing it for example as an\nenvironment variable."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"token")," is the peer token provided by the user. It's used to determine the\nuser and the room to be connected to."),(0,a.kt)("p",null,"Now we have to get the answer from the backend that we're connected\nsuccessfully. To do this we need to implement the ",(0,a.kt)("inlineCode",{parentName:"p"},"JellyfishClientListener"),"\ninterface."),(0,a.kt)("p",null,"Firstly we'll implement ",(0,a.kt)("inlineCode",{parentName:"p"},"onAuthSuccess()")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"onAuthError()")," callbacks."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"onAuthSuccess()")," is called when the user is authenticated successfully and can\nset up tracks to stream and join the room. So we'll do so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:"title=MainViewModel.kt",title:"MainViewModel.kt"},"class MainViewModel(application: Application) : AndroidViewModel(application),\n// highlight-next-line\n    JellyfishClientListener {\n\n    // ...\n\n// highlight-next-line\n    private var localVideoTrack: LocalVideoTrack? = null\n\n    // highlight-start\n    private fun setupTracks() {\n        val videoParameters = VideoParameters.presetHD169\n        localVideoTrack = client.createVideoTrack(videoParameters, emptyMap())\n    }\n\n    override fun onAuthSuccess() {\n        setupTracks()\n        client.join()\n    }\n\n\n    // highlight-end\n}\n")),(0,a.kt)("p",null,"In ",(0,a.kt)("inlineCode",{parentName:"p"},"setupTracks()")," function we set up a local video track to stream. We use a\npreset with reasonable defaults, but there are many settings you can customize\n(resolution, bandwidth, simulcast etc.). The local video track streams the local\ndevice camera. You can also set up an audio track, but for the purposes of this\ntutorial we omitted it."),(0,a.kt)("p",null,"Then in ",(0,a.kt)("inlineCode",{parentName:"p"},"onAuthSuccess()")," after setting up tracks we join the room. When user\njoins the room, the user is able to receive tracks from other peers and\nvice-versa."),(0,a.kt)("p",null,"Don't forget to implement also ",(0,a.kt)("inlineCode",{parentName:"p"},"onAuthError()")," function - it's called when the\nauthentication failed and you should handle it by for example informing the user\nthat something went wrong."),(0,a.kt)("p",null,"Backend informs us that user succesfully joined the room in ",(0,a.kt)("inlineCode",{parentName:"p"},"onJoined")," callback.\nIn ",(0,a.kt)("inlineCode",{parentName:"p"},"onJoined")," callback we also receive information about other peers in the room\nand local user id. We're going to store information about peers in ",(0,a.kt)("inlineCode",{parentName:"p"},"MainViewModel"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:"title=MainViewModel.kt",title:"MainViewModel.kt"},"class MainViewModel(application: Application) : AndroidViewModel(application),\n    JellyfishClientListener {\n    // ...\n    val participants = MutableStateFlow<List<Participant>>(emptyList())\n    val isConnected = MutableStateFlow(false)\n\n    private val mutableParticipants = HashMap<String, Participant>()\n\n    // ...\n\n     override fun onJoined(peerID: String, peersInRoom: List<Peer>) {\n        peersInRoom.forEach {\n            mutableParticipants[it.id] = Participant(\n                it.id,\n            )\n        }\n        isConnected.value = true\n        emitParticipants()\n    }\n\n    private fun emitParticipants() {\n        participants.value =\n            mutableParticipants.values.filter { p -> p.videoTrackContext != null }.toList()\n    }\n}\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"participants")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"isConnected")," are state variables that are exposed to the UI\n(",(0,a.kt)("inlineCode",{parentName:"p"},"MainActivity"),"). ",(0,a.kt)("inlineCode",{parentName:"p"},"participants")," stores current peers and updates when peers are\nadded or removed. ",(0,a.kt)("inlineCode",{parentName:"p"},"isConnected")," stores whether the app is connected to the\nserver or not. If it's connected we'll display a screen displaying participants."),(0,a.kt)("p",null,"In ",(0,a.kt)("inlineCode",{parentName:"p"},"onJoined")," callback we add participants that are currently in the room and\nupdate the UI accordingly."),(0,a.kt)("p",null,"Remember to also implement ",(0,a.kt)("inlineCode",{parentName:"p"},"onJoinError")," callback, just like ",(0,a.kt)("inlineCode",{parentName:"p"},"onAuthError"),"."),(0,a.kt)("p",null,"With this you should be able to connect to the server now. Scan the QR code and\nconnect, and in the dashboard you should be able to see video from the camera\non your mobile device."),(0,a.kt)("h2",{id:"room-screen"},"Room screen"),(0,a.kt)("p",null,"Now we need an UI to display other participants. Jellyfish Client provides a\ncomponent for that: ",(0,a.kt)("inlineCode",{parentName:"p"},"VideoTextureViewRenderer"),". Because we're using Jetpack\nCompose and this is just regular Android ",(0,a.kt)("inlineCode",{parentName:"p"},"View"),", we're going to wrap it using\n",(0,a.kt)("inlineCode",{parentName:"p"},"AndroidView")," Composable. Also we'll need to avoid memory leaks by releasing the\nview when necessary."),(0,a.kt)("p",null,"// TODO: to jest g\u0142upie ze user musi si\u0119 tym zajmowa\u0107 zeby ustawi\u0107 renderer i\njeszcze zwalnianiem tego, user powinien m\xf3c po prostu da\u0107 video tracka do tego\nview i wszystko"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:"title=MainActivity.kt",title:"MainActivity.kt"},"\n    @Composable\n    fun ParticipantVideoView(participant: Participant, modifier: Modifier = Modifier) {\n        var activeVideoTrack: VideoTrack? by remember { mutableStateOf(null) }\n        var view: VideoTextureViewRenderer? by remember { mutableStateOf(null) }\n\n        // set the renderer of the track when the view is initialized or updated\n        fun setupTrack(videoTrack: VideoTrack, view: VideoTextureViewRenderer) {\n            if (activeVideoTrack == videoTrack) return\n\n            activeVideoTrack?.removeRenderer(view)\n            videoTrack.addRenderer(view)\n            activeVideoTrack = videoTrack\n        }\n\n        // remove the renderer from the track if the track has changed\n        DisposableEffect(participant.videoTrackContext?.track) {\n            onDispose {\n                view?.let {\n                    (participant.videoTrackContext?.track as VideoTrack).removeRenderer(it)\n                }\n            }\n        }\n\n        // release the view if the view is removed\n        DisposableEffect(currentCompositeKeyHash.toString()) {\n            onDispose {\n                view?.release()\n            }\n        }\n\n        AndroidView(\n            factory = { context ->\n                VideoTextureViewRenderer(context).apply {\n                    // init the VideoTextureViewRenderer with participant's video track\n                    this.init((participant.videoTrackContext?.track as VideoTrack).eglContext, null)\n                    setupTrack((participant.videoTrackContext.track as VideoTrack), this)\n                    view = this\n                }\n            },\n            update = { updatedView ->\n                setupTrack((participant.videoTrackContext?.track as VideoTrack), updatedView)\n            },\n            modifier = modifier,\n        )\n    }\n")),(0,a.kt)("p",null,"Then we'll use the ",(0,a.kt)("inlineCode",{parentName:"p"},"ParticipantVideoView")," to display participants in a grid (using ",(0,a.kt)("inlineCode",{parentName:"p"},"LazyVerticalGrid"),"):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:"title=MainActivity.kt",title:"MainActivity.kt"},"\n    @Composable\n    fun RoomScreen() {\n        val participants = viewModel.participants.collectAsState()\n\n        Column(\n            modifier = Modifier\n                .fillMaxWidth()\n                .fillMaxHeight()\n                .padding(10.dp),\n            verticalArrangement = Arrangement.SpaceBetween,\n            horizontalAlignment = Alignment.CenterHorizontally,\n        ) {\n            LazyVerticalGrid(\n                columns = GridCells.Fixed(if (participants.value.count() > 2) 2 else 1),\n                verticalArrangement = Arrangement.spacedBy(\n                    16.dp,\n                    alignment = Alignment.CenterVertically\n                ),\n                horizontalArrangement = Arrangement.spacedBy(\n                    16.dp,\n                    alignment = Alignment.CenterHorizontally\n                )\n            ) {\n                items(participants.value.count()) {\n                    ParticipantVideoView(\n                        participant = participants.value[it],\n                        modifier = Modifier\n                            .clip(RoundedCornerShape(10.dp))\n                            .aspectRatio(1.0f, matchHeightConstraintsFirst = true)\n                            .fillMaxWidth()\n                            .fillMaxHeight(),\n                    )\n                }\n            }\n        }\n    }\n")),(0,a.kt)("p",null,"To display the Room screen we just need to modify the ",(0,a.kt)("inlineCode",{parentName:"p"},"onCreate")," method in\n",(0,a.kt)("inlineCode",{parentName:"p"},"MainActivity"),". If we're connected, we display the Room screen, otherwise the\nConnect screen."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:"title=MainActivity.kt",title:"MainActivity.kt"},"\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            // highlight-next-line\n            val isConnected = viewModel.isConnected.collectAsState()\n\n            JellyfishDashboardAndroidTheme {\n                // A surface container using the 'background' color from the theme\n                Surface(\n                    modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background\n                ) {\n                    // highlight-start\n                    if (isConnected.value) {\n                        RoomScreen()\n                    } else {\n                        ConnectContent()\n                    }\n                    // highlight-end\n                }\n            }\n        }\n    }\n")),(0,a.kt)("h3",{id:"adding--removing-peers-and-tracks"},"Adding / removing peers and tracks"),(0,a.kt)("p",null,"If you run the app, you'll see that nothing happens if a new participant joins the room. We have to handle this by implementing some more methods from the ",(0,a.kt)("inlineCode",{parentName:"p"},"JellyfishClientListener")," interface:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:"title=MainViewModel.kt",title:"MainViewModel.kt"},'class MainViewModel(application: Application) : AndroidViewModel(application),\n    JellyfishClientListener {\n\n    //...\n\n    override fun onPeerJoined(peer: Peer) {\n        mutableParticipants[peer.id] = Participant(\n            id = peer.id,\n        )\n        emitParticipants()\n    }\n\n    override fun onPeerLeft(peer: Peer) {\n        mutableParticipants.remove(peer.id)\n        emitParticipants()\n    }\n\n    override fun onTrackReady(ctx: TrackContext) {\n        val participant = mutableParticipants[ctx.endpoint.id] ?: return\n\n        val (id, newParticipant) = when (ctx.track) {\n            is RemoteVideoTrack -> {\n                val p = participant.copy(videoTrackContext = ctx)\n                Pair(ctx.endpoint.id, p)\n            }\n            else ->\n                throw IllegalArgumentException("invalid type of incoming remote track")\n        }\n        mutableParticipants[id] = newParticipant\n        emitParticipants()\n    }\n\n    override fun onTrackRemoved(ctx: TrackContext) {\n        val participant = mutableParticipants[ctx.endpoint.id] ?: return\n        val videoTrackId = participant.videoTrackContext?.trackId ?: return\n\n        val newParticipant = if (ctx.trackId == videoTrackId) {\n            participant.copy(videoTrackContext = null)\n        } else {\n            throw IllegalArgumentException("track has not been found for given endpoint")\n        }\n\n        mutableParticipants[ctx.endpoint.id] = newParticipant\n        emitParticipants()\n    }\n}\n')),(0,a.kt)("p",null,"Those methods are rather self-explanatory: ",(0,a.kt)("inlineCode",{parentName:"p"},"onPeerJoined()")," is called when\nsomeone joins the room, ",(0,a.kt)("inlineCode",{parentName:"p"},"onPeerLeft()")," is called when someone leaves the room.\nSimilarly, ",(0,a.kt)("inlineCode",{parentName:"p"},"onTrackReady()")," is called when a track is ready to display and\n",(0,a.kt)("inlineCode",{parentName:"p"},"onTrackRemoved()")," is called when a track is no longer streamed. One peer can\nhave multiple tracks (also multiple video tracks!), but for this tutorial we'll\nassume it's always one video track."),(0,a.kt)("h3",{id:"gracefully-leaving-the-room"},"Gracefully leaving the room"),(0,a.kt)("p",null,"To leave a rooom we'll add a button for the user. When user clicks it, we\ngracefully leave the room, close the server connection and go back to the\nConnect screen."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:"title=MainActivity.kt",title:"MainActivity.kt"},'    @Composable\n    fun RoomScreen() {\n        val participants = viewModel.participants.collectAsState()\n\n        Column(\n            // ...\n        ) {\n            LazyVerticalGrid(\n               // ...\n            ) {\n             // ...\n            }\n            // highlight-start\n            Button(\n                onClick = {\n                    viewModel.disconnect()\n                },\n\n                ) {\n                Text("Disconnect")\n            }\n            // highlight-end\n        }\n    }\n')),(0,a.kt)("p",null,"And in ",(0,a.kt)("inlineCode",{parentName:"p"},"MainViewModel")," we'll add ",(0,a.kt)("inlineCode",{parentName:"p"},"disconnect()")," function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:"title=MainViewModel.kt",title:"MainViewModel.kt"},"class MainViewModel(application: Application) : AndroidViewModel(application),\n    JellyfishClientListener {\n\n    // ...\n\n    fun disconnect() {\n        localVideoTrack?.stop()\n        localVideoTrack = null\n        client.cleanUp()\n        isConnected.value = false\n    }\n}\n")),(0,a.kt)("h2",{id:"summary"},"Summary"),(0,a.kt)("p",null,"Congrats on finishing your first Jellyfish mobile application! In this tutorial\nyou've learned how to make a basic Jellyfish client application that streams and\nreceives video tracks with WebRTC technology."),(0,a.kt)("p",null,"But this was just the beginning. Jellyfish Client supports much more than just\nstreaming camera: it can also stream audio, screencast your device's screen,\nconfigure your camera and audio devices, detect voice activity, control\nsimulcast, bandwidth and encoding settings, show camera preview, display WebRTC\nstats and more to come. Check out our other tutorials to learn about those\nfeatures."),(0,a.kt)("p",null,"You can also take a look at our fully featured ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/jellyfish-dev/react-native-membrane-webrtc/tree/master/example"},"Videoroom Demo\nexample"),":"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Videoroom Demo",src:t(6143).Z,width:"720",height:"720"})),(0,a.kt)("p",null,"It's in React Native, but actually React Native SDK uses Android SDK under the hood!"))}u.isMDXComponent=!0},2596:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/adding_peer-fe855d9a06e818ed6850260bedaca859.gif"},6143:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/videoroom-b9c2dd933b2f8d5061aa5b5c53c19a3d.gif"}}]);