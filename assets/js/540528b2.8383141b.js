"use strict";(self.webpackChunkclients_tutorial=self.webpackChunkclients_tutorial||[]).push([[451,580,991,270],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),c=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return i.createElement(s.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=c(n),h=a,m=u["".concat(s,".").concat(h)]||u[h]||p[h]||o;return n?i.createElement(m,r(r({ref:t},d),{},{components:n})):i.createElement(m,r({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:a,r[1]=l;for(var c=2;c<o;c++)r[c]=n[c];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},9247:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>c,default:()=>k,frontMatter:()=>s,metadata:()=>d,toc:()=>p});var i=n(7462),a=(n(7294),n(3905)),o=n(5968),r=n(9239),l=n(8823);const s={},c="iOS Quickstart Guide",d={unversionedId:"quickstart/ios-quickstart",id:"quickstart/ios-quickstart",title:"iOS Quickstart Guide",description:"What you'll learn",source:"@site/docs/quickstart/ios-quickstart.mdx",sourceDirName:"quickstart",slug:"/quickstart/ios-quickstart",permalink:"/clients-docs/docs/quickstart/ios-quickstart",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/quickstart/ios-quickstart.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Android Quickstart Guide",permalink:"/clients-docs/docs/quickstart/android-quickstart"},next:{title:"jellyfish-architecture",permalink:"/clients-docs/docs/quickstart/jellyfish-architecture"}},u={},p=[{value:"What you&#39;ll learn",id:"what-youll-learn",level:2},{value:"What do you need",id:"what-do-you-need",level:2},{value:"Jellyfish architecture",id:"jellyfish-architecture",level:2},{value:"Setup",id:"setup",level:2},{value:"Add dependencies",id:"add-dependencies",level:3},{value:"Start the Jellyfish backend",id:"start-the-jellyfish-backend",level:3},{value:"Start the dashboard web front-end",id:"start-the-dashboard-web-front-end",level:3},{value:"App permissions",id:"app-permissions",level:3},{value:"Connecting to the server and joining the room",id:"connecting-to-the-server-and-joining-the-room",level:2},{value:"App structure",id:"app-structure",level:3},{value:"Connect screen",id:"connect-screen",level:3},{value:"QR Code scanning",id:"qr-code-scanning",level:3},{value:"Connecting to the backend",id:"connecting-to-the-backend",level:3},{value:"Room screen",id:"room-screen",level:2},{value:"Adding / removing peers and tracks",id:"adding--removing-peers-and-tracks",level:3},{value:"Gracefully leaving the room",id:"gracefully-leaving-the-room",level:3},{value:"Summary",id:"summary",level:2}],h={toc:p},m="wrapper";function k(e){let{components:t,...s}=e;return(0,a.kt)(m,(0,i.Z)({},h,s,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"ios-quickstart-guide"},"iOS Quickstart Guide"),(0,a.kt)("h2",{id:"what-youll-learn"},"What you'll learn"),(0,a.kt)("p",null,"This tutorial will guide you through creating your first iOS project which\nuses Jellyfish client. By the end of the tutorial, you'll have a working\napplication that connects to the front-end dashboard using WebRTC technology and\nstreams and receives camera tracks."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Finished app",src:n(5759).Z,width:"640",height:"1136"})),(0,a.kt)("p",null,"You can check out the finished project ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/graszka22/clients-docs"},"here"),"."),(0,a.kt)("h2",{id:"what-do-you-need"},"What do you need"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"a little bit of experience in creating iOS apps in Swift and SwiftUI"),(0,a.kt)("li",{parentName:"ul"},"Xcode IDE, iOS device for testing")),(0,a.kt)("h2",{id:"jellyfish-architecture"},"Jellyfish architecture"),(0,a.kt)(o.default,{mdxType:"JellyfishArchitecture"}),(0,a.kt)("h2",{id:"setup"},"Setup"),(0,a.kt)("h3",{id:"add-dependencies"},"Add dependencies"),(0,a.kt)("p",null,"Jelllyfish Client for iOS is a Swift package, so you can add it simply in Xcode.\nGo to ",(0,a.kt)("inlineCode",{parentName:"p"},"File")," -> ",(0,a.kt)("inlineCode",{parentName:"p"},"Add packages")," and enter package github repo url (",(0,a.kt)("inlineCode",{parentName:"p"},"https://github.com/jellyfish-dev/ios-client-sdk"),"):"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"File -&gt; Add packages",src:n(6559).Z,width:"928",height:"402"})),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Enter package url",src:n(1132).Z,width:"2194",height:"1256"})),(0,a.kt)("h3",{id:"start-the-jellyfish-backend"},"Start the Jellyfish backend"),(0,a.kt)(r.default,{mdxType:"StartingJellyfishBackend"}),(0,a.kt)("h3",{id:"start-the-dashboard-web-front-end"},"Start the dashboard web front-end"),(0,a.kt)(l.default,{mdxType:"StartingJellyfishDashboard"}),(0,a.kt)("h3",{id:"app-permissions"},"App permissions"),(0,a.kt)("p",null,"In ",(0,a.kt)("inlineCode",{parentName:"p"},"Info.plist")," file you have to set ",(0,a.kt)("inlineCode",{parentName:"p"},"NSCameraUsageDescription"),". You can edit\nthis file in Xcode. This value is a description that is shown when iOS asks the user\nfor camera permission."),(0,a.kt)("p",null,"We also suggest setting background mode to ",(0,a.kt)("inlineCode",{parentName:"p"},"audio")," so that the app doesn't\ndisconnect when it's in the background:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml",metastring:"title=Info.plist",title:"Info.plist"},"<key>UIBackgroundModes</key>\n<array>\n  <string>audio</string>\n</array>\n")),(0,a.kt)("h2",{id:"connecting-to-the-server-and-joining-the-room"},"Connecting to the server and joining the room"),(0,a.kt)("p",null,"Our app will consist of two screens. The first one allows user to type, paste or\nscan the peer token and connect to the room. The second screen shows room\nparticipants with their video tracks."),(0,a.kt)("h3",{id:"app-structure"},"App structure"),(0,a.kt)("p",null,"To write the app we'll use SwiftUI. Firstly, create a new iOS application\nproject. You'll see a ",(0,a.kt)("inlineCode",{parentName:"p"},"ContentView.swift")," file created for you. In this file\nwe're going to put UI related code. On the other hand, the code responsible for\nthe business logic of the app (storing data, managing state of the app,\nconnecting to the server) will be put in ",(0,a.kt)("inlineCode",{parentName:"p"},"ContentViewController.swift"),"."),(0,a.kt)("p",null,"We'll have also a small file for things related to styling. Feel free to skip this step and style\nyour components however you want, we just put them there for completness."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift",metastring:"title=Theme.swift",title:"Theme.swift"},"import SwiftUI\n\nlet seaBlue40 = Color(red:0.749, green:0.906, blue:0.973)\nlet seaBlue20 = Color(red:0.945, green:0.98, blue:0.996)\nlet darkBlue100 = Color(red:0, green:0.102, blue:0.447)\nlet darkText = Color(red:0, green:0.102, blue:0.447)\n\nstruct ButtonStyle: ViewModifier {\n  func body(content: Content) -> some View {\n    content.padding()\n      .frame(maxWidth: .infinity)\n      .background(darkBlue100)\n      .foregroundColor(.white)\n      .cornerRadius(100)\n  }\n}\n\nstruct TextFieldStyle: ViewModifier {\n  func body(content: Content) -> some View {\n    content.padding()\n      .foregroundColor(.black)\n      .background(.white)\n      .cornerRadius(100)\n      .overlay(\n        RoundedRectangle(cornerRadius: 100)\n          .stroke(darkBlue100, lineWidth: 2)\n      )\n  }\n}\n")),(0,a.kt)("p",null,"Of course your app might be a lot more complicated and use a different\nstructure. The two screens should be probably separated in different files, we\nshould use some kind of navigation etc. For this tutorial though, this simple\nstructure should be enough."),(0,a.kt)("h3",{id:"connect-screen"},"Connect screen"),(0,a.kt)("p",null,"The UI of the Connect screen consists of a simple text input and a few buttons.\nThe flow for this screen is simple: user either copies the peer token from the\ndashboard or scans it with QR code scanner and presses Connect button. The QR\ncode scanner is completely optional, but we'll show how to add it for convenience."),(0,a.kt)("p",null,"The code for the connect screen UI is straightforward:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift",metastring:'title="ContentView.swift',title:'"ContentView.swift'},'struct ConnectScreen: View {\n  @State private var peerToken = ""\n\n  var body: some View {\n    VStack {\n      TextField("Enter peer token...", text: $peerToken)\n        .modifier(TextFieldStyle())\n\n      Button(action: {\n        // added later\n      }) {\n        Text("Connect").modifier(ButtonStyle())\n      }\n      Button(action: {\n        // added later\n      }) {\n        Text("Scan QR code").modifier(ButtonStyle())\n      }\n    }\n    .padding(10)\n    .frame(maxWidth: .infinity, maxHeight: .infinity)\n    .background(seaBlue40)\n  }\n}\n')),(0,a.kt)("h3",{id:"qr-code-scanning"},"QR Code scanning"),(0,a.kt)("p",null,"We know that copy-paste from desktop to mobile device is annoying. That's why to\ncopy the peer token from the dashboard we'll use QR code scanning. We'll use a\nstandard iOS library (AVFoundation) for this."),(0,a.kt)("p",null,"Create a new file ",(0,a.kt)("inlineCode",{parentName:"p"},"QRScanner.swift")," with the following contents:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift",metastring:"title=QRScanner.swift",title:"QRScanner.swift"},'import SwiftUI\nimport AVFoundation\n\nclass QRScannerController: UIViewController {\n  var captureSession = AVCaptureSession()\n  var videoPreviewLayer: AVCaptureVideoPreviewLayer?\n  var qrCodeFrameView: UIView?\n\n  var delegate: AVCaptureMetadataOutputObjectsDelegate?\n\n  override func viewDidLoad() {\n    super.viewDidLoad()\n\n    guard let captureDevice = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back) else {\n      print("Failed to get the camera device")\n      return\n    }\n\n    let videoInput: AVCaptureDeviceInput\n\n    do {\n      videoInput = try AVCaptureDeviceInput(device: captureDevice)\n\n    } catch {\n      print(error)\n      return\n    }\n\n    captureSession.addInput(videoInput)\n\n    let captureMetadataOutput = AVCaptureMetadataOutput()\n    captureSession.addOutput(captureMetadataOutput)\n\n    captureMetadataOutput.setMetadataObjectsDelegate(delegate, queue: DispatchQueue.main)\n    captureMetadataOutput.metadataObjectTypes = [ .qr ]\n\n    videoPreviewLayer = AVCaptureVideoPreviewLayer(session: captureSession)\n    videoPreviewLayer?.videoGravity = AVLayerVideoGravity.resizeAspectFill\n    videoPreviewLayer?.frame = view.layer.bounds\n    view.layer.addSublayer(videoPreviewLayer!)\n\n    DispatchQueue.global(qos: .background).async {\n      self.captureSession.startRunning()\n    }\n\n  }\n}\n\nstruct QRScanner: UIViewControllerRepresentable {\n  var onQRCodeScanned: (_ code: String) -> Void\n\n  init(_ onQRCodeScanned: @escaping (_ code: String) -> Void) {\n    self.onQRCodeScanned = onQRCodeScanned\n  }\n\n  func updateUIViewController(_ uiViewController: QRScannerController, context: Context) {\n  }\n\n  func makeCoordinator() -> Coordinator {\n    Coordinator(onQRCodeScanned)\n  }\n\n  func makeUIViewController(context: Context) -> QRScannerController {\n    let controller = QRScannerController()\n    controller.delegate = context.coordinator\n\n    return controller\n  }\n}\n\nclass Coordinator: NSObject, AVCaptureMetadataOutputObjectsDelegate {\n  var onQRCodeScanned: ((_ code: String) -> Void)?\n\n  init(_ onQRCodeScanned: @escaping (_ code: String) -> Void) {\n    self.onQRCodeScanned = onQRCodeScanned\n  }\n\n  func metadataOutput(_ output: AVCaptureMetadataOutput, didOutput metadataObjects: [AVMetadataObject], from connection: AVCaptureConnection) {\n    if metadataObjects.count == 0 {\n      return\n    }\n\n    let metadataObj = metadataObjects[0] as! AVMetadataMachineReadableCodeObject\n\n    if metadataObj.type == AVMetadataObject.ObjectType.qr,\n       let result = metadataObj.stringValue {\n      if let onQRCodeScanned = onQRCodeScanned {\n        onQRCodeScanned(result)\n      }\n      onQRCodeScanned = nil\n    }\n  }\n}\n')),(0,a.kt)("p",null,"We won't go into details as it's not the main topic of this tutorial. The most\nimportant class here is ",(0,a.kt)("inlineCode",{parentName:"p"},"QRScanner"),". We can use it in our UI, just like any\nSwiftUI component. As an argument it takes a callback that is called when the\ncode is scanned. We'll put this component in a modal, which is shown after\nclicking ",(0,a.kt)("inlineCode",{parentName:"p"},"Scan QR code")," button:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift",metastring:"title=ContentView.swift",title:"ContentView.swift"},'struct ConnectScreen: View {\n  // ...\n\n  var body: some View {\n    VStack {\n      // ...\n      Button(action: {\n        // highlight-next-line\n        showingSheet.toggle()\n      }) {\n        Text("Scan QR code").modifier(ButtonStyle())\n      }\n      // highlight-start\n      .sheet(isPresented: $showingSheet) {\n        VStack {\n          QRScanner() { code in\n            peerToken = code\n            showingSheet.toggle()\n          }\n        }\n      }\n      // highlight-end\n    }\n    // ...\n  }\n}\n')),(0,a.kt)("p",null,"Now if you scan the code, the peer token should appear in the text field."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Scanning qr code",src:n(9896).Z,width:"1920",height:"1080"})),(0,a.kt)("h3",{id:"connecting-to-the-backend"},"Connecting to the backend"),(0,a.kt)("p",null,"Time to write code to connect to the backend. It will be responsibility of the\n",(0,a.kt)("inlineCode",{parentName:"p"},"ContentViewController"),". Let's create the controller:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift",metastring:"title=ContentViewController.swift",title:"ContentViewController.swift"},"class ContentViewController: ObservableObject {\n    @Published var isConnected: Bool = false\n}\n")),(0,a.kt)("p",null,"And connect it with the ",(0,a.kt)("inlineCode",{parentName:"p"},"ContentView"),". Depending on whether we're connected or\nnot, we display the appropriate screen:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift",metastring:"title=ContentView.swift",title:"ContentView.swift"},"// highlight-start\nstruct ContentView: View {\n  @ObservedObject var contentViewController: ContentViewController\n\n  init() {\n    self.contentViewController = ContentViewController()\n  }\n\n  var body: some View {\n    if !contentViewController.isConnected {\n      ConnectScreen(contentViewController: contentViewController)\n    } else {\n      RoomScreen(contentViewController: contentViewController)\n    }\n  }\n}\n// highlight-end\n\nstruct ConnectScreen: View {\n  // highlight-next-line\n  let contentViewController: ContentViewController\n  // ...\n}\n")),(0,a.kt)("p",null,"Now to actually connect to the backend, create ",(0,a.kt)("inlineCode",{parentName:"p"},"JellyfishClient")," instance and call ",(0,a.kt)("inlineCode",{parentName:"p"},"connect()")," function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift",metastring:"title=ContentViewController.swift",title:"ContentViewController.swift"},'class ContentViewController: ObservableObject {\n  private var jellyfishClient: JellyfishClientSdk?\n\n  public init() {\n    self.jellyfishClient = JellyfishClientSdk(listener: self)\n  }\n\n  public func connect(peerToken: String) {\n    let conf = Config(\n      websocketUrl: "ws://192.168.0.31:4000/socket/peer/websocket",\n      token: peerToken\n    )\n    jellyfishClient?.connect(config: conf)\n  }\n}\n')),(0,a.kt)("p",null,"the ",(0,a.kt)("inlineCode",{parentName:"p"},"websocketUrl")," is the url of Jellyfish backend, be sure to change it to your\nlocal backend. Also we strongly recommend storing it for example as an\nenvironment variable."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"token")," is the peer token provided by the user. It's used to determine the\nuser and the room to be connected to."),(0,a.kt)("p",null,"Now we have to get the answer from the backend that we're connected\nsuccessfully. To do this we need to implement the ",(0,a.kt)("inlineCode",{parentName:"p"},"JellyfishClientListener"),"\nprotocol."),(0,a.kt)("p",null,"Firstly we'll implement ",(0,a.kt)("inlineCode",{parentName:"p"},"onAuthSuccess()")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"onAuthError()")," callbacks."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"onAuthSuccess()")," is called when the user is authenticated successfully and can\nset up tracks to stream and join the room. So we'll do so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift",metastring:"title=ContentViewController.swift",title:"ContentViewController.swift"},"class ContentViewController: ObservableObject, JellyfishClientListener {\n    // ...\n\n// highlight-next-line\n  var localVideoTrack: LocalVideoTrack?\n\n// highlight-start\n  func setupTracks() {\n    self.localVideoTrack = jellyfishClient?.createVideoTrack(videoParameters: VideoParameters.presetHD169, metadata: .init())\n  }\n\n\n  func onAuthSuccess() {\n    setupTracks()\n    jellyfishClient?.join(peerMetadata: .init())\n  }\n\n  func onAuthError() {}\n  // highlight-end\n}\n")),(0,a.kt)("p",null,"In ",(0,a.kt)("inlineCode",{parentName:"p"},"setupTracks()")," function we set up a local video track to stream. We use a\npreset with reasonable defaults, but there are many settings you can customize\n(resolution, bandwidth, simulcast etc.). The local video track streams the local\ndevice camera. You can also set up an audio track, but for the purposes of this\ntutorial we omitted it."),(0,a.kt)("p",null,"Then in ",(0,a.kt)("inlineCode",{parentName:"p"},"onAuthSuccess()")," after setting up tracks we join the room. When user\njoins the room, the user is able to receive tracks from other peers and\nvice-versa."),(0,a.kt)("p",null,"Don't forget to implement also ",(0,a.kt)("inlineCode",{parentName:"p"},"onAuthError()")," function - it's called when the\nauthentication failed and you should handle it by for example informing the user\nthat something went wrong."),(0,a.kt)("p",null,"Backend informs us that user succesfully joined the room in ",(0,a.kt)("inlineCode",{parentName:"p"},"onJoined")," callback.\nIn ",(0,a.kt)("inlineCode",{parentName:"p"},"onJoined")," callback we also receive information about other peers in the room\nand local user id. We're going to store information about peers in ",(0,a.kt)("inlineCode",{parentName:"p"},"ContentViewController"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift",metastring:"title=ContentViewController.swift",title:"ContentViewController.swift"},"// highlight-start\nclass Participant: Identifiable {\n  let id: String\n  var videoTrackContext: TrackContext? = nil\n\n  init(id: String) {\n    self.id = id\n  }\n}\n// highlight-start\n\nclass ContentViewController: ObservableObject, JellyfishClientListener {\n  // ...\n  // highlight-start\n  private var mutableParticipants:[String:Participant] = [:]\n  @Published var participants: [Participant] = []\n  // highlight-end\n\n  // ...\n\n // highlight-start\n  func onJoined(peerID: String, peersInRoom: [Peer]) {\n    peersInRoom.forEach { peer in mutableParticipants[peer.id] = Participant(id: peer.id)}\n    DispatchQueue.main.async {\n      self.isConnected = true\n    }\n    emitParticipants()\n  }\n\n  func onJoinError(metadata _: Any) {\n  }\n  // highlight-end\n}\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Participant")," is a simple class for storing data about participants - in this\nexample it's just their id and track context."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"participants")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"isConnected")," are state variables that are exposed to the UI\n(",(0,a.kt)("inlineCode",{parentName:"p"},"ContentView"),"). ",(0,a.kt)("inlineCode",{parentName:"p"},"participants")," stores current peers and updates when peers are\nadded or removed."),(0,a.kt)("p",null,"In ",(0,a.kt)("inlineCode",{parentName:"p"},"onJoined")," callback we add participants that are currently in the room and\nupdate the UI accordingly."),(0,a.kt)("p",null,"Remember to also implement ",(0,a.kt)("inlineCode",{parentName:"p"},"onJoinError")," callback, just like ",(0,a.kt)("inlineCode",{parentName:"p"},"onAuthError"),"."),(0,a.kt)("p",null,"With this you should be able to connect to the server now. Scan the QR code and\nconnect, and in the dashboard you should be able to see video from the camera\non your mobile device."),(0,a.kt)("h2",{id:"room-screen"},"Room screen"),(0,a.kt)("p",null,"Now we need an UI to display other participants. Jellyfish Client provides a\ncomponent for that: ",(0,a.kt)("inlineCode",{parentName:"p"},"SwiftUIVideoView"),". We'll put it in a grid."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},(0,a.kt)("inlineCode",{parentName:"p"},"SwiftUIVideoView")," is a wrapper around Jellyfish Client's ",(0,a.kt)("inlineCode",{parentName:"p"},"VideoView"),". So if\nyou're not using Swift UI you can use ",(0,a.kt)("inlineCode",{parentName:"p"},"VideoView"),".")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift",metastring:"title=ContentView.swift",title:"ContentView.swift"},'struct RoomScreen: View {\n  @ObservedObject var contentViewController: ContentViewController\n\n  var body: some View {\n     VStack {\n      ForEach(Array(stride(from: 0, to: contentViewController.participants.count, by: 2)), id: \\.self) { index in\n        HStack {\n          SwiftUIVideoView((contentViewController.participants[index].videoTrackContext?.track as? VideoTrack)!)\n            .aspectRatio(CGSize(width: 1, height: 1), contentMode: .fit)\n            .cornerRadius(20)\n          if index + 1 < contentViewController.participants.count {\n            SwiftUIVideoView((contentViewController.participants[index+1].videoTrackContext?.track as? VideoTrack)!)\n              .aspectRatio(CGSize(width: 1, height: 1), contentMode: .fit)\n              .cornerRadius(20)\n          }\n        }\n      }\n      Spacer()\n      Button(action: {\n        contentViewController.disconnect()\n      }) {\n        Text("Disconnect").modifier(ButtonStyle())\n      }\n    }\n    .padding(10)\n    .frame(maxWidth: .infinity, maxHeight: .infinity)\n    .background(seaBlue20)\n  }\n}\n')),(0,a.kt)("p",null,"To test it you can add another participant and their new track (displaying for\nexample rotating frog) in the dashboard like this (do it before joining the room):"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Adding new participant",src:n(5807).Z,width:"1760",height:"1148"})),(0,a.kt)("h3",{id:"adding--removing-peers-and-tracks"},"Adding / removing peers and tracks"),(0,a.kt)("p",null,"If you run the app, you'll see that nothing happens if a new participant joins\nthe room while we're joined. We have to handle this by implementing some more\nmethods from the ",(0,a.kt)("inlineCode",{parentName:"p"},"JellyfishClientListener")," protocol:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift",metastring:"title=ContentViewController.swift",title:"ContentViewController.swift"},"class ContentViewController: ObservableObject, JellyfishClientListener {\n  // ...\n\n  func onPeerJoined(peer: Peer) {\n    mutableParticipants[peer.id] = Participant(id: peer.id)\n    emitParticipants()\n  }\n\n  func onPeerLeft(peer: Peer) {\n    mutableParticipants.removeValue(forKey: peer.id)\n    emitParticipants()\n  }\n\n  func onTrackReady(ctx: TrackContext) {\n    guard let participant = mutableParticipants[ctx.peer.id] else {\n      return\n    }\n\n    participant.videoTrackContext = ctx\n\n    mutableParticipants[ctx.peer.id] = participant\n\n    emitParticipants()\n  }\n\n  func onTrackRemoved(ctx: TrackContext) {\n    guard let participant = mutableParticipants[ctx.peer.id],\n          let _ = participant.videoTrackContext?.trackId else {\n      return\n    }\n\n    participant.videoTrackContext = nil\n\n    mutableParticipants[ctx.peer.id] = participant\n    emitParticipants()\n  }\n}\n")),(0,a.kt)("p",null,"Those methods are rather self-explanatory: ",(0,a.kt)("inlineCode",{parentName:"p"},"onPeerJoined()")," is called when\nsomeone joins the room, ",(0,a.kt)("inlineCode",{parentName:"p"},"onPeerLeft()")," is called when someone leaves the room.\nSimilarly, ",(0,a.kt)("inlineCode",{parentName:"p"},"onTrackReady()")," is called when a track is ready to display and\n",(0,a.kt)("inlineCode",{parentName:"p"},"onTrackRemoved()")," is called when a track is no longer streamed."),(0,a.kt)("h3",{id:"gracefully-leaving-the-room"},"Gracefully leaving the room"),(0,a.kt)("p",null,"To leave a rooom we'll add a button for the user. When user clicks it, we\ngracefully leave the room, close the server connection and go back to the\nConnect screen."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift",metastring:"title=ContentView.swift",title:"ContentView.swift"},'struct RoomScreen: View {\n  // ...\n\n  var body: some View {\n    VStack {\n      // ...\n      // highlight-start\n      Spacer()\n      Button(action: {\n        contentViewController.disconnect()\n      }) {\n        Text("Disconnect").modifier(ButtonStyle())\n      }\n      // highlight-end\n    }\n    // ...\n  }\n}\n')),(0,a.kt)("p",null,"And in ",(0,a.kt)("inlineCode",{parentName:"p"},"ContentViewController")," we'll add the",(0,a.kt)("inlineCode",{parentName:"p"},"disconnect()")," function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift",metastring:"title=ContentViewController.swift",title:"ContentViewController.swift"},"class ContentViewController: ObservableObject, JellyfishClientListener {\n  // ...\n  // highlight-start\n  public func disconnect() {\n    jellyfishClient?.cleanUp()\n    DispatchQueue.main.async {\n      self.isConnected = false\n    }\n  }\n  // highlight-end\n}\n")),(0,a.kt)("h2",{id:"summary"},"Summary"),(0,a.kt)("p",null,"Congrats on finishing your first Jellyfish mobile application! In this tutorial,\nyou've learned how to make a basic Jellyfish client application that streams and\nreceives video tracks with WebRTC technology."),(0,a.kt)("p",null,"But this was just the beginning. Jellyfish Client supports much more than just\nstreaming camera: it can also stream audio, screencast your device's screen,\nconfigure your camera and audio devices, detect voice activity, control\nsimulcast, bandwidth and encoding settings, show camera preview, display WebRTC\nstats and more to come. Check out our other tutorials to learn about those\nfeatures."),(0,a.kt)("p",null,"You can also take a look at our fully featured ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/jellyfish-dev/react-native-membrane-webrtc/tree/master/example"},"Videoroom Demo\nexample"),":"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Videoroom Demo",src:n(650).Z,width:"720",height:"720"})),(0,a.kt)("p",null,"It's in React Native, but actually React Native SDK uses iOS SDK under the hood!"))}k.isMDXComponent=!0},5968:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var i=n(7462),a=(n(7294),n(3905));const o={},r=void 0,l={unversionedId:"quickstart/jellyfish-architecture",id:"quickstart/jellyfish-architecture",title:"jellyfish-architecture",description:"You can learn more about Jellyfish architecture in [Jellyfish",source:"@site/docs/quickstart/jellyfish-architecture.mdx",sourceDirName:"quickstart",slug:"/quickstart/jellyfish-architecture",permalink:"/clients-docs/docs/quickstart/jellyfish-architecture",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/quickstart/jellyfish-architecture.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"iOS Quickstart Guide",permalink:"/clients-docs/docs/quickstart/ios-quickstart"},next:{title:"React Native / Expo Quickstart Guide",permalink:"/clients-docs/docs/quickstart/react-native-quickstart"}},s={},c=[{value:"Connecting and joining the room",id:"connecting-and-joining-the-room",level:3}],d={toc:c},u="wrapper";function p(e){let{components:t,...o}=e;return(0,a.kt)(u,(0,i.Z)({},d,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"You can learn more about Jellyfish architecture in ",(0,a.kt)("a",{parentName:"p",href:"https://jellyfish-dev.github.io/jellyfish-docs/"},"Jellyfish\ndocs"),". This section provides a\nbrief description aimed at front-end developers")),(0,a.kt)("p",null,"Let's introduce some concepts first:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Peer")," - A peer is a client-side entity that connects to the server to\npublish, subscribe or publish and subscribe to tracks published by components\nor other peers. You can think of it as a participant in a room. At the moment,\nthere is only one type of peer - WebRTC."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Track")," - An object that represents an audio or video stream. A track can be\nassociated with a local media source, such as a camera or microphone, or a\nremote media source received from another user. Tracks are used to capture,\ntransmit, and receive audio and video data in WebRTC applications."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Room")," - In Jellyfish, a room serves as a holder for peers and components,\nits function varying based on application. From a front-end perspective, this will\nbe probably one meeting or a broadcast.")),(0,a.kt)("p",null,"For a better understanding of these concepts here is an example of a room that\nholds a standard WebRTC conference from a perspective of the User:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Room example",src:n(7027).Z,width:"1195",height:"1224"})),(0,a.kt)("p",null,"In this example, peers stream multiple video and audio tracks. Peer #1 streams\neven two video tracks (camera and screencast track). You can differentiate\nbetween them by using track metadata. The user gets info about peers and their\ntracks from the server using Jellyfish Client. The user is also informed in real\ntime about peers joining/leaving and tracks being added/removed."),(0,a.kt)("p",null,"To keep this tutorial short we'll simplify things a little. Every peer will stream just one\nvideo track."),(0,a.kt)("h3",{id:"connecting-and-joining-the-room"},"Connecting and joining the room"),(0,a.kt)("p",null,"The general flow of connecting to the server and joining the room in a standard\nWebRTC conference setup looks like this:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Connecting and joing the room",src:n(8299).Z,width:"2668",height:"1031"})),(0,a.kt)("p",null,"The parts that you need to implement are marked in blue and things handled by\nJellyfish are marked in red."),(0,a.kt)("p",null,"Firstly, the user logs in. Then your backend authenticates the user and obtains\na peer token. It allows the user to authenticate and join the room in Jellyfish\nServer. The backend passes the token to your front-end, and your front-end passes\nit to Jellyfish Client. The client establishes the connection with Jellyfish\nServer. Then Jellyfish Client sets up tracks (camera, microphone) to stream and\njoins the room on Jellyfish Server. Finally, your front-end can display the room\nfor the user."),(0,a.kt)("p",null,"For this tutorial we simplified this process a bit - you don't have to implement\na backend or authentication. Jellyfish Dashboard will do this for you. It's also\na nice tool to test and play around with Jellyfish. The flow with Jellyfish\nDashboard looks like this:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Connecting and joing the room with dashboard",src:n(2260).Z,width:"2668",height:"1031"})),(0,a.kt)("p",null,"You can see that the only things you need to implement are interactions with the\nuser and Jellyfish Client. This tutorial will show you how to do it."))}p.isMDXComponent=!0},8823:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var i=n(7462),a=(n(7294),n(3905));const o={},r=void 0,l={unversionedId:"quickstart/starting-dashboard",id:"quickstart/starting-dashboard",title:"starting-dashboard",description:"// TODO nie wiem jak to ostatecznie bedzie wygl\u0105da\u0107",source:"@site/docs/quickstart/starting-dashboard.mdx",sourceDirName:"quickstart",slug:"/quickstart/starting-dashboard",permalink:"/clients-docs/docs/quickstart/starting-dashboard",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/quickstart/starting-dashboard.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"React Native / Expo Quickstart Guide",permalink:"/clients-docs/docs/quickstart/react-native-quickstart"},next:{title:"starting-jellyfish-backend",permalink:"/clients-docs/docs/quickstart/starting-jellyfish-backend"}},s={},c=[],d={toc:c},u="wrapper";function p(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"// TODO nie wiem jak to ostatecznie bedzie wygl\u0105da\u0107"))}p.isMDXComponent=!0},9239:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var i=n(7462),a=(n(7294),n(3905));const o={},r=void 0,l={unversionedId:"quickstart/starting-jellyfish-backend",id:"quickstart/starting-jellyfish-backend",title:"starting-jellyfish-backend",description:"For testing, we'll run the backend locally using Docker image:",source:"@site/docs/quickstart/starting-jellyfish-backend.mdx",sourceDirName:"quickstart",slug:"/quickstart/starting-jellyfish-backend",permalink:"/clients-docs/docs/quickstart/starting-jellyfish-backend",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/quickstart/starting-jellyfish-backend.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"starting-dashboard",permalink:"/clients-docs/docs/quickstart/starting-dashboard"}},s={},c=[],d={toc:c},u="wrapper";function p(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"For testing, we'll run the backend locally using Docker image:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"docker run -p 50000-50050:50000-50050/udp \\\n           -p 4000:4000/tcp \\\n           -e WEBRTC_USED=true \\\n           -e INTEGRATED_TURN_PORT_RANGE=50000-50050 \\\n           -e INTEGRATED_TURN_IP=192.168.0.1 \\\n           -e INTEGRATED_TURN_LISTEN_IP=0.0.0.0 \\\n           -e SERVER_API_TOKEN=development \\\n           -e VIRTUAL_HOST=192.168.0.1 \\\n           -e SECRET_KEY_BASE=secret \\\n           ghcr.io/jellyfish-dev/jellyfish:edge\n")),(0,a.kt)("p",null,"Make sure to set ",(0,a.kt)("inlineCode",{parentName:"p"},"INTEGRATED_TURN_IP")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"VIRTUAL_HOST")," to your local IP address. Without it, the mobile device won't be able to connect to the backend."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"To check your local IP you can use this handy command (Linux/macOS):"),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"ifconfig | grep \"inet \" | grep -Fv 127.0.0.1 | awk '{print $2}'\n"))))}p.isMDXComponent=!0},6559:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/add_package_ios_1-52ebaf83f276fcc908fcf4f1e839e2b9.png"},1132:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/add_package_ios_2-207c286403a0b6a43f90c844006017b5.png"},5807:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/adding_new_track-e8d0ce9cfc75bb797be53eae5772ee09.gif"},8299:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/connection-ce8e7756cdcd65fe387cf34e617bea2e.png"},2260:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/dashboard_connection-0c46d267a83447871297ff6f538dfc32.png"},5759:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/ios_full_app-9bdb7e660df9cc0a0375222d3771b179.gif"},7027:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/room_example-e9c6acb4df6063de5a8978dc6710b909.png"},9896:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/scan_qr_ios-4dae42436f42c15f390cab493ab7e746.gif"},650:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/videoroom-b9c2dd933b2f8d5061aa5b5c53c19a3d.gif"}}]);